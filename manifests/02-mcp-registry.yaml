---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mcp-registry-data
  namespace: mcp-registry
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-registry-config
  namespace: mcp-registry
data:
  registry.json: |
    {
      "registry": {
        "name": "mcp-registry",
        "version": "1.0.0",
        "description": "Central registry for MCP tools",
        "storage": {
          "type": "filesystem",
          "path": "/data/registry"
        },
        "api": {
          "port": 8080,
          "host": "0.0.0.0"
        },
        "features": {
          "authentication": false,
          "versioning": true,
          "validation": true
        }
      }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-registry
  namespace: mcp-registry
  labels:
    app: mcp-registry
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mcp-registry
  template:
    metadata:
      labels:
        app: mcp-registry
    spec:
      containers:
        - name: registry
          image: registry.access.redhat.com/ubi9/ubi-minimal:latest
          command:
            - /bin/bash
            - -c
            - |
              # Install Python and dependencies
              microdnf install -y python3 python3-pip && \
              pip3 install flask pyyaml && \
              # Start the registry server
              python3 /opt/registry/server.py
          ports:
            - containerPort: 8080
              name: http
              protocol: TCP
          volumeMounts:
            - name: registry-data
              mountPath: /data/registry
            - name: registry-config
              mountPath: /etc/registry
            - name: registry-server
              mountPath: /opt/registry
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
      volumes:
        - name: registry-data
          persistentVolumeClaim:
            claimName: mcp-registry-data
        - name: registry-config
          configMap:
            name: mcp-registry-config
        - name: registry-server
          configMap:
            name: mcp-registry-server
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-registry-server
  namespace: mcp-registry
data:
  server.py: |
    #!/usr/bin/env python3
    """
    Simple MCP Registry Server
    """
    import json
    import os
    import re
    from flask import Flask, jsonify, request
    from pathlib import Path

    app = Flask(__name__)
    REGISTRY_PATH = Path("/data/registry")
    REGISTRY_PATH.mkdir(parents=True, exist_ok=True)

    def is_valid_tool_name(name):
        """Validate tool name to prevent path traversal attacks."""
        if not name or not isinstance(name, str):
            return False
        # Allow only alphanumeric, hyphens, and underscores
        if not re.match(r'^[a-zA-Z0-9_-]+$', name):
            return False
        # Prevent path traversal attempts
        if '..' in name or '/' in name or '\\' in name:
            return False
        return True

    def get_tool_path(tool_name):
        """Safely construct tool file path."""
        if not is_valid_tool_name(tool_name):
            return None
        tool_file = REGISTRY_PATH / f"{tool_name}.json"
        # Ensure the resolved path is within REGISTRY_PATH
        try:
            tool_file = tool_file.resolve()
            if not str(tool_file).startswith(str(REGISTRY_PATH.resolve())):
                return None
        except (OSError, RuntimeError):
            return None
        return tool_file

    @app.route('/health')
    def health():
        return jsonify({"status": "healthy"}), 200

    @app.route('/ready')
    def ready():
        return jsonify({"status": "ready"}), 200

    @app.route('/api/v1/tools', methods=['GET'])
    def list_tools():
        tools = []
        if REGISTRY_PATH.exists():
            for tool_file in REGISTRY_PATH.glob("*.json"):
                try:
                    with open(tool_file) as f:
                        tools.append(json.load(f))
                except (json.JSONDecodeError, IOError) as e:
                    app.logger.error(f"Error reading {tool_file}: {e}")
                    continue
        return jsonify({"tools": tools}), 200

    @app.route('/api/v1/tools/<tool_name>', methods=['GET'])
    def get_tool(tool_name):
        tool_file = get_tool_path(tool_name)
        if not tool_file:
            return jsonify({"error": "Invalid tool name"}), 400
        
        if tool_file.exists():
            try:
                with open(tool_file) as f:
                    return jsonify(json.load(f)), 200
            except (json.JSONDecodeError, IOError) as e:
                app.logger.error(f"Error reading tool {tool_name}: {e}")
                return jsonify({"error": "Error reading tool data"}), 500
        return jsonify({"error": "Tool not found"}), 404

    @app.route('/api/v1/tools', methods=['POST'])
    def create_tool():
        try:
            tool_data = request.get_json()
        except Exception as e:
            return jsonify({"error": "Invalid JSON data"}), 400
        
        if not tool_data:
            return jsonify({"error": "Request body required"}), 400
        
        tool_name = tool_data.get("name")
        if not tool_name:
            return jsonify({"error": "Tool name required"}), 400
        
        tool_file = get_tool_path(tool_name)
        if not tool_file:
            return jsonify({"error": "Invalid tool name. Use only alphanumeric, hyphens, and underscores"}), 400
        
        try:
            with open(tool_file, 'w') as f:
                json.dump(tool_data, f, indent=2)
        except (IOError, OSError) as e:
            app.logger.error(f"Error writing tool {tool_name}: {e}")
            return jsonify({"error": "Error saving tool data"}), 500
        
        return jsonify({"message": "Tool created", "tool": tool_data}), 201

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=8080)
