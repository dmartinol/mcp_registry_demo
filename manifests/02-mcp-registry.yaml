---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mcp-registry-data
  namespace: mcp-registry
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-registry-config
  namespace: mcp-registry
data:
  registry.json: |
    {
      "registry": {
        "name": "mcp-registry",
        "version": "1.0.0",
        "description": "Central registry for MCP tools",
        "storage": {
          "type": "filesystem",
          "path": "/data/registry"
        },
        "api": {
          "port": 8080,
          "host": "0.0.0.0"
        },
        "features": {
          "authentication": false,
          "versioning": true,
          "validation": true
        }
      }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-registry
  namespace: mcp-registry
  labels:
    app: mcp-registry
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mcp-registry
  template:
    metadata:
      labels:
        app: mcp-registry
    spec:
      containers:
        - name: registry
          image: registry.access.redhat.com/ubi9/ubi-minimal:latest
          command:
            - /bin/bash
            - -c
            - |
              # Install Python and dependencies
              microdnf install -y python3 python3-pip && \
              pip3 install flask pyyaml && \
              # Start the registry server
              python3 /opt/registry/server.py
          ports:
            - containerPort: 8080
              name: http
              protocol: TCP
          volumeMounts:
            - name: registry-data
              mountPath: /data/registry
            - name: registry-config
              mountPath: /etc/registry
            - name: registry-server
              mountPath: /opt/registry
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
      volumes:
        - name: registry-data
          persistentVolumeClaim:
            claimName: mcp-registry-data
        - name: registry-config
          configMap:
            name: mcp-registry-config
        - name: registry-server
          configMap:
            name: mcp-registry-server
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-registry-server
  namespace: mcp-registry
data:
  server.py: |
    #!/usr/bin/env python3
    """
    Simple MCP Registry Server
    """
    import json
    import os
    from flask import Flask, jsonify, request
    from pathlib import Path

    app = Flask(__name__)
    REGISTRY_PATH = Path("/data/registry")
    REGISTRY_PATH.mkdir(parents=True, exist_ok=True)

    @app.route('/health')
    def health():
        return jsonify({"status": "healthy"}), 200

    @app.route('/ready')
    def ready():
        return jsonify({"status": "ready"}), 200

    @app.route('/api/v1/tools', methods=['GET'])
    def list_tools():
        tools = []
        if REGISTRY_PATH.exists():
            for tool_file in REGISTRY_PATH.glob("*.json"):
                with open(tool_file) as f:
                    tools.append(json.load(f))
        return jsonify({"tools": tools}), 200

    @app.route('/api/v1/tools/<tool_name>', methods=['GET'])
    def get_tool(tool_name):
        tool_file = REGISTRY_PATH / f"{tool_name}.json"
        if tool_file.exists():
            with open(tool_file) as f:
                return jsonify(json.load(f)), 200
        return jsonify({"error": "Tool not found"}), 404

    @app.route('/api/v1/tools', methods=['POST'])
    def create_tool():
        tool_data = request.get_json()
        tool_name = tool_data.get("name")
        if not tool_name:
            return jsonify({"error": "Tool name required"}), 400
        
        tool_file = REGISTRY_PATH / f"{tool_name}.json"
        with open(tool_file, 'w') as f:
            json.dump(tool_data, f, indent=2)
        return jsonify({"message": "Tool created", "tool": tool_data}), 201

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=8080)
